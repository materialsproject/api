# ruff: noqa
from __future__ import annotations

from datetime import datetime
from typing import Literal, Any

import plotly.graph_objects as plotly_go

from emmet.core.chemenv import (
    COORDINATION_GEOMETRIES,
    COORDINATION_GEOMETRIES_IUCR,
    COORDINATION_GEOMETRIES_IUPAC,
    COORDINATION_GEOMETRIES_NAMES,
)
from emmet.core.electronic_structure import BSPathType, DOSProjectionType
from emmet.core.grain_boundary import GBTypeEnum
from emmet.core.mpid import MPID
from emmet.core.summary import HasProps
from emmet.core.symmetry import CrystalSystem
from emmet.core.synthesis import OperationTypeEnum, SynthesisTypeEnum
from emmet.core.thermo import ThermoType
from emmet.core.vasp.calc_types import CalcType
from emmet.core.xas import Edge, Type
from pymatgen.analysis.magnetism.analyzer import Ordering
from pymatgen.core.periodic_table import Element
from pymatgen.core.composition import Composition
from pymatgen.core.structure import Structure
from pymatgen.electronic_structure.core import OrbitalType, Spin
from pymatgen.entries.computed_entries import ComputedEntry

from mp_api.client.core import MPRestError
from mp_api.mcp.utils import _NeedsMPClient
from mp_api.mcp._schemas import SearchOutput, FetchResult, MaterialMetadata


class MPCoreMCP(_NeedsMPClient):
    """Define LLM-agnostic MCP for the Materials Project API.

    Because this MCP must support all common LLMs, it defines two methods,
    `search` and `fetch`, which are compatible with OpenAI's spec.
    """

    @staticmethod
    def _validate_chemical_system_formula(q: str) -> dict[str, str]:
        """Check if a string query is a chemical formula or chemical system."""
        structured_query: dict[str, str] = {}
        if "," not in q:
            if "-" in q:
                try:
                    structured_query["chemsys"] = "-".join(
                        Element(k).value for k in sorted(q.split("-"))
                    )
                except Exception:
                    pass
            else:
                try:
                    structured_query["formula"] = Composition(q).formula
                except Exception:
                    pass

        return structured_query

    def search(self, query: str) -> SearchOutput:
        """Define OpenAI compatible search.

        Search through the autogenerated robocrystallographer
        descriptions of materials to return lists of likely
        matching materials.

        Does not return the detailed `metadata` associated with a material.
        To retrieve this, use the `fetch` method for a given result `id`.

        Args:
            query (str) : A natural language query of either:
                - comma-delimited keywords, example: "polyhedra,orthorhombic,superconductor".
                    This should contain no whitespace; all whitespace will be removed.
                - chemical formula, example: "TiO2"
                - dash-delimited elements for more general chemical system, example: "Li-P-S"
            To query by formula or chemical system, no commas should be present in the query.

        Returns:
            SearchOutput, a dict of `results` each with structure
            mp_api.mcp._schemas.SearchOutput
        """
        robo_docs: list = []
        if summary_query := self._validate_chemical_system_formula(query):
            # Check if query by chemical system / formula
            material_ids = [
                doc["material_id"]
                for doc in self.client.materials.summary.search(
                    **summary_query, fields=["material_id"]
                )
            ]
            robo_docs += self.client.materials.robocrys.search_docs(
                material_ids=material_ids, fields=["description", "material_id"]
            )
        else:
            robo_docs += self.client.materials.robocrys.search(
                query.replace(" ", "").split(",")
            )

        return SearchOutput(
            results=[
                FetchResult(id=doc["material_id"], text=doc["description"])  # type: ignore[call-arg]
                for doc in robo_docs
            ]
        )

    def _aggregate_fetch_results_from_mpids(
        self,
        mpids: list[str] | None,
    ) -> list[FetchResult]:
        """Aggregate results across endpoints to format MCP tool output.

        Args:
            mpids (list of str, or None) :  A list of Materials Project IDs
                or None.

        Returns:
            list of FetchResult containing information on the materials
            in the documents.
        """

        summary_docs = self.client.materials.summary.search(
            material_ids=mpids, fields=MaterialMetadata._summary_fields()
        )
        similarity_docs = self.client.materials.similarity.search(
            material_ids=mpids, fields=["sim", "material_id"]
        )

        robo_desc_by_mpid = {
            doc["material_id"]: doc["description"]
            for doc in self.client.materials.robocrys.search_docs(
                material_ids=mpids, fields=["description", "material_id"]
            )
        }

        sim_scores_by_mpid = {
            doc["material_id"]: ", ".join(
                f"{entry['task_id']}: {entry['formula']} ({100. - entry['dissimilarity']:.1f}% similar)"
                for entry in sorted(doc["sim"], key=lambda e: e["dissimilarity"])[:10]
            )
            for doc in (similarity_docs or [])
            if not any(e["dissimilarity"] is None for e in doc["sim"])
        }

        return [
            FetchResult(  # type: ignore[call-arg]
                id=doc["material_id"],
                text=robo_desc_by_mpid.get(doc["material_id"]),
                metadata=MaterialMetadata.from_summary_data(
                    doc,
                    structurally_similar_materials=sim_scores_by_mpid.get(
                        doc["material_id"]
                    ),
                ),
            )
            for doc in summary_docs
        ]

    def fetch_all(self) -> list[FetchResult]:
        """Retrieve complete material information for the entire Materials Project.

        Returns:
            list of FetchResult : Complete document with id, title, robocrys
                autogenerated description, URL, and metadata derived from
                the materials summary collection, as available.
        """

        return self._aggregate_fetch_results_from_mpids(None)

    def _validate_identifiers(
        self, idxs: list[str], limit_one_per_chemsys: bool = False
    ) -> list[str]:
        """Validate that identifiers can be interpreted by the MCP tools.

        Args:
            idxs (list of str) : The input string identifier
            limit_one_per_chemsys (bool = False) : Whether to reduce to one
                identifier per chemsys (used by `fetch`)

        Returns:
            list of str : the identifiers as valid MPIDs

        Raises:
            MPRestError on malformatted `idxs`
        """

        if len(invalid_idxs := {idx for idx in idxs if not isinstance(idx, str)}) > 0:
            raise MPRestError(
                f"Unknown identifiers:\n{', '.join(invalid_idxs)}\n"
                "Should be a Materials Project ID, "
                "chemical formula, or chemical system."
            )

        # Assume this is a chemical formula or chemical system
        non_mp_ids: set[str] = {idx for idx in idxs if "mp-" not in idx}
        chemsys: set[str] = {
            "-".join(sorted(idx.split("-"))) for idx in non_mp_ids if "-" in idx
        }
        formula: set[str] = {idx for idx in non_mp_ids if "-" not in idx}

        valid_mpids = set(idxs) - non_mp_ids
        summ_docs: list[dict[str, Any]] = []
        if chemsys:
            summ_docs += self.client.materials.summary.search(
                chemsys=list(chemsys),
                fields=["material_id", "energy_above_hull", "chemsys"],
            )
        if formula:
            summ_docs += self.client.materials.summary.search(
                formula=list(formula),
                fields=["material_id", "energy_above_hull", "chemsys"],
            )

        if limit_one_per_chemsys:
            by_chemsys: dict[str, dict[str, Any]] = {}
            for doc in summ_docs:
                if doc["chemsys"] not in by_chemsys:
                    by_chemsys[doc["chemsys"]] = {
                        "material_id": None,
                        "energy_above_hull": float("inf"),
                    }
                if (
                    doc["energy_above_hull"]
                    < by_chemsys[doc["chemsys"]]["energy_above_hull"]
                ):
                    by_chemsys[doc["chemsys"]] = {
                        k: doc[k] for k in ("material_id", "energy_above_hull")
                    }
            new_mpids = {e["material_id"] for e in by_chemsys.values()}
        else:
            new_mpids = {doc["material_id"] for doc in summ_docs}

        return list(valid_mpids.union(new_mpids))

    def fetch_many(
        self, str_idxs: str, limit_one_per_chemsys: bool = False
    ) -> list[FetchResult]:
        """Retrieve complete material information for a list of materials.

        Should only be used to retrieve at most 100 materials.
        For larger lists, use the `fetch_all` method and filter down.

        May return fewer than 100 results if identical chemical
        systems or formulas which exist in the same chemical system
        were specified.

        Args:
            str_idxs (str) : A list of Materials Project IDs,
                chemical formulas, or chemical systems, separated by
                commas, e.g., "mp-13, LiCl, Fe-O"
            limit_one_per_chemsys (bool) : Whether to limit to one
                entry per chemical system.

        Returns:
            list of FetchResult with detailed material metadata.

        Raises:
            MPRestError if any identifiers are malformatted, or if
                more than 100 identifiers are specified.
        """
        idxs = [idx.strip() for idx in str_idxs.split(",")]
        if len(idxs) > 100:
            raise MPRestError(
                f"{len(idxs)} identifiers were specified, either submit at "
                "most 100 identifiers or use `fetch_all` to retrieve all "
                "data and filter down."
            )
        idxs = self._validate_identifiers(
            idxs,
            limit_one_per_chemsys=limit_one_per_chemsys,
        )
        return self._aggregate_fetch_results_from_mpids(idxs)

    def fetch(self, idx: str) -> FetchResult:
        """Retrieve complete material information by Materials Project ID, formula, or chemical system.

        Args:
            idx (str) : A Materials Project ID, chemical formula, or chemical system.

            If a Materials Project ID, this should be an integer prefixed by `mp-`.
            Examples: "mp-149", "mp-13"

            If a chemical formula, only the most stable structure with that
            reduced chemical formula is returned.
            Examples: LiFePO4, Si

            If a chemical system, should be a dash-delimited list of elements.
            The elements do not need to be sorted.
            Examples: Ga-As, Si-P-O

        Returns:
            FetchResult : Complete document with id, title, robocrys
            autogenerated description, URL, and metadata derived from
            the materials summary collection.

            If no data about the particular id is available, returns a
            FetchResult with only the id field populated.

        Raises:
            MPRestError: If no identifier is specified
        """
        return self.fetch_many(idx, limit_one_per_chemsys=True)[0]

    def get_phase_diagram_from_elements(
        self,
        elements: str,
        thermo_type: Literal[  # type: ignore[valid-type]
            *[x.value for x in ThermoType.__members__.values() if x.value != "UNKNOWN"]
        ]
        | str = "GGA_GGA+U_R2SCAN",
    ) -> plotly_go.Figure:
        """Find a thermodynamic phase diagram in the Materials Project by specified elements.

        Args:
            elements (str) : a list of comma-separated elements
            thermo_type (str) : One of emmet.core.types.enums.ThermoType
                - "GGA_GGA+U" to use PBE GGA and PBE+U mixed data
                - "R2SCAN" to use the r2SCAN only hull
                - "GGA_GGA+U_R2SCAN" to use the "GGA_GGA+U" hull mixed with r2SCAN data

        Returns:
            plotly.graph_objects.Figure representing the phase diagram.

        Examples:
        Given elements Na and Cl:
        ```
        phase_diagram = MPCoreMCP().get_phase_diagram_from_elements(
            elements = "Na, Cl",
        )
        ```

        Given a chemical system, "K-P-O":
        ```
        phase_diagram =  MPCoreMCP().get_phase_diagram_from_elements(
            elements = ",".join("K-P-O".split("-")),
        )
        ```

        """
        pd = self.client.materials.thermo.get_phase_diagram_from_chemsys(
            "-".join([e.strip() for e in elements.split(",")]), thermo_type
        )
        return pd.get_plot()  # has to be JSON serializable
