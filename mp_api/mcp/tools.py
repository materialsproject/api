# ruff: noqa
from __future__ import annotations

from datetime import datetime
from typing import Literal, Any

import plotly.graph_objects as plotly_go

from emmet.core.chemenv import (
    COORDINATION_GEOMETRIES,
    COORDINATION_GEOMETRIES_IUCR,
    COORDINATION_GEOMETRIES_IUPAC,
    COORDINATION_GEOMETRIES_NAMES,
)
from emmet.core.electronic_structure import BSPathType, DOSProjectionType
from emmet.core.grain_boundary import GBTypeEnum
from emmet.core.mpid import MPID
from emmet.core.summary import HasProps
from emmet.core.symmetry import CrystalSystem
from emmet.core.synthesis import OperationTypeEnum, SynthesisTypeEnum
from emmet.core.thermo import ThermoType
from emmet.core.vasp.calc_types import CalcType
from emmet.core.xas import Edge, Type
from pymatgen.analysis.magnetism.analyzer import Ordering
from pymatgen.core.periodic_table import Element
from pymatgen.core.composition import Composition
from pymatgen.core.structure import Structure
from pymatgen.electronic_structure.core import OrbitalType, Spin
from pymatgen.entries.computed_entries import ComputedEntry

from mp_api.client.core import MPRestError
from mp_api.mcp.utils import _NeedsMPClient
from mp_api.mcp._schemas import SearchOutput, FetchResult, MaterialMetadata


class MPCoreMCP(_NeedsMPClient):
    """Define LLM-agnostic MCP for the Materials Project API.

    Because this MCP must support all common LLMs, it defines two methods,
    `search` and `fetch`, which are compatible with OpenAI's spec.
    """

    @staticmethod
    def _validate_chemical_system_formula(q: str) -> dict[str, str]:
        """Check if a string query is a chemical formula or chemical system."""
        structured_query: dict[str, str] = {}
        if "," not in q:
            if "-" in q:
                try:
                    structured_query["chemsys"] = "-".join(
                        Element(k).value for k in sorted(q.split("-"))
                    )
                except Exception:
                    pass
            else:
                try:
                    structured_query["formula"] = Composition(q).formula
                except Exception:
                    pass

        return structured_query

    def search(self, query: str) -> SearchOutput:
        """Define OpenAI compatible search.

        Search through the autogenerated robocrystallographer
        descriptions of materials to return lists of likely
        matching materials.

        Does not return the detailed `metadata` associated with a material.
        To retrieve this, use the `fetch` method for a given result `id`.

        Args:
            query (str) : A natural language query of either:
                - comma-delimited keywords, example: "polyhedra,orthorhombic,superconductor".
                    This should contain no whitespace; all whitespace will be removed.
                - chemical formula, example: "TiO2"
                - dash-delimited elements for more general chemical system, example: "Li-P-S"
            To query by formula or chemical system, no commas should be present in the query.

        Returns:
            SearchOutput, a dict of `results` each with structure
            mp_api.mcp._schemas.SearchOutput
        """
        robo_docs: list = []
        if summary_query := self._validate_chemical_system_formula(query):
            # Check if query by chemical system / formula
            material_ids = [
                doc["material_id"]
                for doc in self.client.materials.summary.search(
                    **summary_query, fields=["material_id"]
                )
            ]
            robo_docs += self.client.materials.robocrys.search_docs(
                material_ids=material_ids, fields=["description", "material_id"]
            )
        else:
            robo_docs += self.client.materials.robocrys.search(
                query.replace(" ", "").split(",")
            )

        return SearchOutput(
            results=[
                FetchResult(
                    id=doc["material_id"],
                    text=doc["description"],
                )
                for doc in robo_docs
            ]
        )

    def fetch(self, idx: str) -> FetchResult:
        """Retrieve complete material information by Materials Project ID, formula, or chemical system.

        Args:
            idx (str) : A Materials Project ID, chemical formula, or chemical system.

            If a Materials Project ID, this should be an integer prefixed by `mp-`.
            Examples: "mp-149", "mp-13"

            If a chemical formula, only the most stable structure with that
            reduced chemical formula is returned.
            Examples: LiFePO4, Si

            If a chemical system, should be a dash-delimited list of elements.
            The elements do not need to be sorted.
            Examples: Ga-As, Si-P-O

        Returns:
            FetchResult : Complete document with id, title, robocrys
            autogenerated description, URL, and metadata derived from
            the materials summary collection.

            If no data about the particular id is available, returns a
            FetchResult with only the id field populated.

        Raises:
            MPRestError: If no identifier is specified
        """

        if not isinstance(idx, str):
            raise MPRestError(
                f"Unknown {idx=}. Should be a Materials Project ID, "
                "chemical formula, or chemical system."
            )

        # Assume this is a chemical formula or chemical system
        if "mp-" not in idx:
            summ_kwargs = {"fields": ["energy_above_hull", "material_id"]}
            if "-" in idx:
                summ_kwargs["chemsys"] = "-".join(sorted(idx.split("-")))
            else:
                summ_kwargs["formula"] = idx

            if not (summ_docs := self.client.materials.summary.search(**summ_kwargs)):
                return FetchResult(id=idx)

            idx = min(summ_docs, key=lambda doc: doc["energy_above_hull"])[
                "material_id"
            ]

        robo_desc: str | None = None
        if (
            len(
                robo_docs := self.client.materials.robocrys.search_docs(
                    material_ids=[idx]
                )
            )
            > 0
        ):
            robo_desc = robo_docs[0]["description"]

        if not robo_desc:
            return FetchResult(id=idx)

        metadata: dict[str, str] = {}

        if len(sim_docs := self.client.materials.similarity.find_similar(idx, top=10)):
            if not isinstance(sim_docs[0], dict):
                sim_docs = [doc.model_dump() for doc in sim_docs]
            metadata.update(
                structurally_similar_materials=(
                    ", ".join(
                        f"{doc['task_id']}: {doc['formula']} ({100. - doc['dissimilarity']:.1f}% similar)"
                        for doc in sim_docs
                    )
                )
            )

        summary_doc = {}
        if (
            len(
                summary_docs := self.client.materials.summary.search(
                    material_ids=[idx],
                    fields=MaterialMetadata._summary_fields(),
                )
            )
            > 0
        ):
            # Try to avoid more nested fields, just provide things with
            # simple str or numeric type
            summary_doc = summary_docs[0]

        return FetchResult(
            id=idx,
            text=robo_desc,
            metadata=MaterialMetadata.from_summary_data(summary_doc, **metadata),
        )

    def get_phase_diagram_from_elements(
        self,
        elements: list[str],
        thermo_type: Literal[
            *[x.value for x in ThermoType.__members__.values() if x.value != "UNKNOWN"]
        ]
        | str = "GGA_GGA+U_R2SCAN",
    ) -> plotly_go.Figure:
        """Find a thermodynamic phase diagram in the Materials Project by specified elements.

        Examples:
        Given elements Na and Cl:
        ```
        phase_diagram = MPMcpTools().get_phase_diagram_from_elements(
            elements = ["Na","Cl"],
        )
        ```

        Given a chemical system, "K-P-O":
        ```
        phase_diagrasm =  MPMcpTools().get_phase_diagram_from_elements(
            elements = "K-P-O".split("-"),
        )
        ```

        """
        pd = self.client.materials.thermo.get_phase_diagram_from_chemsys(
            "-".join(elements), thermo_type
        )
        return pd.get_plot()  # has to be JSON serializable
